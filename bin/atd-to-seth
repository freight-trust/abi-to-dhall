#!/usr/bin/env node
const fs = require('fs')
const { spawn } = require('child_process');

const command = process.argv[2]
const opts = process.argv.slice(3)
const enableEstimates = opts.indexOf("--estimate") !== -1
const enableNonce = opts.indexOf("--nonce") !== -1

function error(msg) {
  console.error(`Error: ${msg}`)
  process.exit(1)
}

function argTypes(node) {
  return node.join(',')
}

function args(node) {
  return node.map(op).map(x => `"${x}"`).join(' ')
}

function outputVal(type, val) {
  return /^u?int/.test(type) ? val : `\\"${val}\\"`
}

function output(node) {
  const type = node.type
  const value = node.value
  const json =
    (value.op === 'lit')
    ? (Array.isArray(value.value)
      ? `[ ${value.value.map(v => outputVal(type, v)).join(', ')} ]`
      : outputVal(type, value.value))
    : `\\"${op(value)}\\"`
  return `out "${node.id}" "${json}"`
}

function estimate(node) {
  if (!enableEstimates) return ""

  const parse =
    { send: n => `est $(seth estimate "${op(n.address)}" "${n.function}(${argTypes(n.argTypes)})" ${args(n.args)})`
    , call: n => `est $(seth estimate "${op(n.address)}" "${n.function}(${argTypes(n.argTypes)})(${argTypes(n.outputTypes)})" ${args(n.args)}) `
    , create: n => `est $(seth estimate --create "./atd/evm/${n.prefix}${n.contract}.bin" "${n.contract}(${argTypes(n.argTypes)})" ${args(n.args)})`
    }

  if (!(node.op in parse)) return ""

  return parse[node.op](node) + "\n"
}

function nonce() {
  return enableNonce ? "\nETH_NONCE=$((ETH_NONCE + 1))" : ""
}

function sendAsync() {
  return enableNonce ? "SETH_ASYNC=yes " : ""
}

function op(node) {
  const parse =
    { def: n => `${estimate(n.def)}_def_${n.id}=$(${op(n.def)})${nonce()}`
    , send: n => `${estimate(n)}${sendAsync()}seth send "${op(n.address)}" "${n.function}(${argTypes(n.argTypes)})" ${args(n.args)}${nonce()}`
    , call: n => `seth call "${op(n.address)}" "${n.function}(${argTypes(n.argTypes)})(${argTypes(n.outputTypes)})" ${args(n.args)}`
    , create: n => `seth send --create "./atd/evm/${n.prefix}${n.contract}.bin" "${n.contract}(${argTypes(n.argTypes)})" ${args(n.args)}`
    , naturalToUint256: n => `$(seth --to-uint256 "${n.naturalToUint256}")`
    , integerToInt256: n => `$(seth --to-int256 "${n.integerToInt256}")`
    , hexToBytes32: n => `$(seth --to-bytes32 "${op(n.hexToBytes32)}")`
    , asciiToHex: n => `$(seth --from-ascii "${n.asciiToHex}")`
    , sig: n => `$(seth sig "${n.sig}")`
    , callDef: n => `\${_def_${n.callDef}}`
    , lit: n => n.value
    , output: output
    }

  if (!(node.op in parse))
    error(`OP type "${node.op}" not recognized.`)

  return parse[node.op](node)
}

function ast(node) {
  const ops = node.ops.map(op)
  return `#!/usr/bin/env bash
echo -n "{";
trap 'exit 130' INT
trap 'exit 131' TERM
trap '{ echo "$_sep \\"meta\\":
  { \\"runtime\\": \\"atd-to-seth\\"
  , \\"estimates\\": [$estimates ]
  , \\"exit\\": $?
  , \\"date\\": \\"$(date -u +"%FT%T.000Z")\\"
  }
}"; } 2>/dev/null' EXIT
set -ex

out() { { echo "$_sep \\"$1\\": $2";_sep=,; } 2>/dev/null; }${
enableEstimates ? `
est() { { estimates+="$_esep $1";_esep=,; } 2>/dev/null; }` : ""
}${
enableNonce ? `
export ETH_NONCE=$(seth nonce "$ETH_FROM")` : ""
}

${ops.join("\n")}`
}

const data = fs.readFileSync(0, 'utf-8')
const script = ast(JSON.parse(data))

if (command === 'run') {
  const child = spawn('bash')
  child.stdout.pipe(process.stdout, { end: false });
  child.stderr.pipe(process.stderr, { end: false });
  child.stdin.write(script)
  child.stdin.end();
} else {
  console.log(script)
}
