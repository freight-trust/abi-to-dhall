#!/usr/bin/env bash
set -eo pipefail

filepath() {
  echo "$(cd ${1%/*} && pwd)/${1##*/}"
}

LIB_DIR=$(cd "${LIB_DIR-${0%/*}/../dhall}" && pwd)
PRELUDE_PATH=$(cd "${PRELUDE_PATH-${0%/*}/../dhall-lang/Prelude}" && pwd)
PACKAGE_PATH="$LIB_DIR/package.dhall"
if [[ $1 =~ / ]]; then
  BACKEND_PATH=$(filepath "$1")
else
  BACKEND_PATH=$(filepath "$LIB_DIR/backends/$1.dhall")
fi
OUT_DIR="$PWD/atd" #$(mktemp -d)
OUT_LIB_DIR="$OUT_DIR"
OUT_ABI_DIR="$OUT_DIR/abi"

#trap 'trap - EXIT; rm -rf "$OUT_DIR"' EXIT

gen() {
  local abiPath
  abiPath="$1"
  local contractName
  contractName="${abiPath##*/}"
  contractName="${contractName%.*}"
  local abiDhall
  abiDhall="$OUT_ABI_DIR/abi_$contractName.dhall"

  echo -n >&2 "$abiPath -> "

  if {
    sed 's/\[\]"/_list"/g' "$abiPath" \
      | json-to-dhall --records-strict --unions-strict "($PACKAGE_PATH).abiSchema.Abi" \
      > "$abiDhall" \
    && dhall text <<<"($PACKAGE_PATH).abiGenerator $BACKEND_PATH \"$contractName\" $abiDhall" \
      | dhall format > "$OUT_ABI_DIR/$contractName"
  }; then
    echo >&2 "$OUT_ABI_DIR/$contractName"
  else
    echo >&2 "Failed!"
    exit 1
  fi
}

#rm -rf "$OUT_ABI_DIR" "$OUT_LIB_DIR"
mkdir -p "$OUT_ABI_DIR" "$OUT_LIB_DIR"
ln -s "$PRELUDE_PATH" "$OUT_LIB_DIR/Prelude"
dhall <<<"($PACKAGE_PATH).lib" > "$OUT_LIB_DIR/lib"
dhall <<<"($BACKEND_PATH).util" > "$OUT_LIB_DIR/backend"

types='(
  let List/map = '"$PRELUDE_PATH"'/List/map
  let Natural/enumerate = '"$PRELUDE_PATH"'/Natural/enumerate
  let Conv = ('"$PACKAGE_PATH"').typesHelper.Conv
  let IntConv = { Type = Conv.Type, default = Conv::{ type = "Integer", conv = "Integer/show" } }
  let NatConv = { Type = Conv.Type, default = Conv::{ type = "Natural", conv = "Natural/show" } }
  in
  [ Conv::{ name = "void" }
  , Conv::{ name = "hex" }
  , Conv::{ name = "address" }
  , Conv::{ name = "bytes" }
  , NatConv::{ name = "uint" }
  , IntConv::{ name = "int" }
  ]
  # List/map Natural Conv.Type
      (λ(i : Natural) → Conv::{ name = "bytes${Natural/show (i + 1)}" })
      (Natural/enumerate 32)
  # List/map Natural Conv.Type
      (λ(i : Natural) → NatConv::{ name = "uint${Natural/show (i * 8 + 8)}" })
      (Natural/enumerate 32)
  # List/map Natural Conv.Type
      (λ(i : Natural) → IntConv::{ name = "int${Natural/show (i * 8 + 8)}" })
      (Natural/enumerate 32)
)'

dhall text <<<"($PACKAGE_PATH).typesGenerator $BACKEND_PATH $types" \
  | dhall format > "$OUT_LIB_DIR/types"

for fn in "${@:2}"; do gen "$fn"; done
