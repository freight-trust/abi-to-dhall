#!/usr/bin/env bash
set -eo pipefail

BIN_PATH=$(cd "${0%/*}" && pwd)

usage() {
  if [ "$1" ]; then echo >&2 "Error: $1"; fi
  echo >&2 "
Usage: atd
          init  [ABI_DIR]
          run   [--runtime RUNTIME] ([--ast FILE] | [--file FILE] | [--expr EXPR] | [-- EXPR..])
          print [--runtime RUNTIME] ([--ast FILE] | [--file FILE] | [--expr EXPR] | [-- EXPR..])
          ast   ([--file FILE] | [--expr EXPR] | [-- EXPR..])

Commands:
  init    Create './atd' directory
  run     Execute a deployment plan
  print   Print deployment plan to STDOUT
  ast     Print JSON AST to STDOUT (alias for \`atd print --runtime json ...\`)

Arguments:
  ABI_DIR
          Path to a directory containing ABI files

Options:
  -r,--runtime RUNTIME
          Select a runtime 'sh' or 'json' ('sh' only available for \`run\`)
  -a,--ast FILE
          A deploy AST file to use instead of Dhall code
  -f,--file FILE
          A Dhall expression to evaluate as deploy config
  -e,--expr DHALL_EXPRESSION
          A Dhall expression to evaluate as deploy config
  -- DHALL_EXPRESSION..
          Use rest of arguments as a Dhall expression (similar to --expr)

Global environment:
  DAPP_OUT
          Dapp output directory to look for '*.abi' and '*.bin' solidity files
"
  exit 1
}

setExpr() {
  [[ -z $astFile && -z $expression ]] \
    || usage "Arguments --ast, --file, --expr and -- are mutually exclusive."
  expression="$1"
}

setAst() {
  [[ -z $astFile && -z $expression ]] \
    || usage "Arguments --ast, --file, --expr and -- are mutually exclusive."
  astFile="$1"
}

init() {
  while [ "$1" ]; do
    case "$1" in
      -*)
        usage "\"$1\" is not a recognized option."
        ;;
      *)
        break
        ;;
    esac
    shift
  done

  local abiDir="${1:-$DAPP_OUT}"
  if [ "$abiDir" ]; then
    rm -rf ./atd
    "$BIN_PATH"/abi-to-dhall "$abiDir"/*.abi
  else
    usage "Not creating './atd' directory because no argument or \$DAPP_OUT given."
  fi
}

parseArgs() {
  while [ "$1" ]; do
    case "$1" in
      -r|--runtime) shift
        case "$1" in
          sh|json)
            [[ -z $runtime ]] || usage "--runtime option given more than once."
            runtime="$1"
            ;;
          *)
            usage "\"$1\" is not a valid runtime, available runtimes: 'sh' or 'json'"
            ;;
        esac
        ;;
      -a|--ast) shift
        [ -f "$1" ] || usage "\"$1\" is not a file."
        setAst "$1"
        ;;
      -f|--file) shift
        [ -f "$1" ] || usage "\"$1\" is not a file."
        setExpr "$(realpath "$1")"
        ;;
      -e|--expr) shift
        setExpr "$1"
        ;;
      --) shift
        setExpr "$*"
        break
        ;;
      *)
        usage "\"$1\" is not a recognized argument."
        ;;
    esac
    shift
  done

  runtime="${runtime:-sh}"
}

print() {
  parseArgs "$@"

  if [ "$astFile" ]; then
    "$BIN_PATH/ast-to-$runtime" < "$astFile"
  else
    [ "$expression" ] || usage "No Dhall expression or file given."
    [ -d ./atd ] || usage "No './atd' directory found try the \`init\` command."
    [[ $(cat ./atd/.backend) == "\"json\"" ]] \
      || usage "$(cat ./atd/.backend) is not a compatible backend, only 'json' is supported."

    dhall text <<<"(./atd/package).render ($expression)" | "$BIN_PATH/ast-to-$runtime"
  fi
}

run() {
  parseArgs "$@"

  [[ $runtime == sh ]] \
    || usage "\`run\` is only compatible with 'sh' runtime for now."
  export DAPP_OUT="${DAPP_OUT:-$PWD/atd/dapp}"
  export DAPP_SKIP_BUILD=yes
  print | exec bash
}

ast() {
  print --runtime json "$@"
}

case "$1" in
  init|run|print|ast)
    $1 "${@:2}"
    ;;
  *)
    usage "\"$1\" is not a command."
    ;;
esac
