#!/usr/bin/env node
const fs = require('fs')
const { spawn } = require('child_process');

function error(msg) {
  console.error(`Error: ${msg}`)
  process.exit(1)
}

function argTypes(node) {
  return node.join(',')
}

function args(node) {
  return node.map(op).map(x => `"${x}"`).join(' ')
}

function outputVal(type, val) {
  return /^u?int/.test(type) ? val : `\\"${val}\\"`
}

function output(node) {
  const type = node.type
  const value = node.value
  const json =
    (value.op === 'lit')
    ? (Array.isArray(value.value)
      ? `[ ${value.value.map(v => outputVal(type, v)).join(', ')} ]`
      : outputVal(type, value.value))
    : `\\"${op(value)}\\"`
  return `out "${node.id}" "${json}"`
}

function op(node) {
  const parse =
    { def: n => `_def_${n.id}=$(${op(n.def)})`
    , send: n => `seth send "${op(n.address)}" "${n.function}(${argTypes(n.argTypes)})" ${args(n.args)}`
    , call: n => `seth call "${op(n.address)}" "${n.function}(${argTypes(n.argTypes)})(${argTypes(n.outputTypes)})" ${args(n.args)}`
    , create: n => `seth send --create "./atd/evm/${n.prefix}${n.contract}.bin" "${n.contract}(${argTypes(n.argTypes)})" ${args(n.args)}`
    , naturalToUint256: n => `$(seth --to-uint256 "${n.naturalToUint256}")`
    , integerToInt256: n => `$(seth --to-int256 "${n.integerToInt256}")`
    , hexToBytes32: n => `$(seth --to-bytes32 "${op(n.hexToBytes32)}")`
    , asciiToHex: n => `$(seth --from-ascii "${n.asciiToHex}")`
    , sig: n => `$(seth sig "${n.sig}")`
    , callDef: n => `\${_def_${n.callDef}}`
    , lit: n => n.value
    , output: output
    }

  if (!(node.op in parse))
    error(`OP type "${node.op}" not recognized.`)

  return parse[node.op](node)
}

function ast(node) {
  const ops = node.ops.map(op)
  return `#!/usr/bin/env bash
echo -n "{";
trap 'exit 130' INT
trap 'exit 131' TERM
trap '{ echo "$_sep \\"meta\\":
  { \\"runtime\\": \\"atd-to-seth\\"
  , \\"exit\\": $?
  , \\"date\\": \\"$(date -u +"%FT%T.000Z")\\"
  }
}"; } 2>/dev/null' EXIT
set -ex

out() { { echo "$_sep \\"$1\\": $2";_sep=,; } 2>/dev/null; }

${ops.join("\n")}`
}

const action = process.argv[2]
const data = fs.readFileSync(0, 'utf-8')
const json = ast(JSON.parse(data))

if (action === 'run') {
  const child = spawn('bash')
  child.stdout.pipe(process.stdout, { end: false });
  child.stderr.pipe(process.stderr, { end: false });
  child.stdin.write(json)
  child.stdin.end();
} else {
  console.log(json)
}
